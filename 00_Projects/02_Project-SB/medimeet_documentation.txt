===============================================================================================================
medimeet documentation
===============================================================================================================

NOTE :
	1) We will keep properties - username and password same to use dto concept

===============================================================================================================
Date : 27 March 2024

1) 
	1a) create a User entity class with properties and constructors + setter getters + toString()
	1b) create an enum UserRoles --> USER,ADMIN,DOCTOR for role of user

	User(C)     
		- userIdentifier(Integer --> AutoIncrement --> IDENTITY)

		- username(String)
		- password(String)

		- userFirstName(String)
		- userLastName(String)
		- userEmailId(String)
		- userRegistrationDate(util.Date) --> CurrentTimeStamp --> updatable false
		- userGender(String)
		- userProfileImage(String --> Lob)
		- userDob(String --> to avoid errors)
		- isPatient(Boolean) --> 
			(when new entity created, we need to assign false as default later on we can set true)
		- userAppointment(Set<Appointment> OneToMany --> One User have Many Appointments)
		- userPrescription(Set<Prescription> OneToMany --> One User have Many Prescriptions)
		- userRole(UserRoles--> enum)
	
	UserRoles(enum)
		- USER , DOCTOR , ADMIN

---------------------------------------------------------------------------------------------------------------

2)
	2a) create a Doctor entity class with properties and constructors + setter getters + toString()
	2b) create a Clinic entity class with properties and constructors + setter getters + toString()

	OneDoctor-Has-OneClinic

	Doctor(C)
		- doctorIdentifier(Integer --> AutoIncrement --> IDENTITY)

		- username(String)
		- password(String)

		- doctorFirstName(String)
		- doctorLastName(String)
		- doctorLicense(String)
		- doctorEmailId(String)
		- doctorContactNumber(Long)
		- doctorSpecialization(String)
		- doctorExperienceInYears(Double)
		- doctorGender(String)
		- doctorProfileImage(String --> Lob)
		- doctorRegistrationDate(Date --> @CurrentTimeStamp --> updatable=false)
		- userRole(UserRoles--> enum)		

		- doctorClinic(Clinic --> @ManyToOne --> many doctors have only one clinic --> JsonManagedReference)
		
		- doctorAppointments(Set<Appointment> --> @OneToMany --> One Doctor have Many Appointments)

	Clinic(C)
		- clinicIdentifier(Integer --> AutoIncrement --> IDENTITY)
		- clinicName(String)
		- clinicOpdCharges(Double)
		- clinicContactNumber(Long)
		- clinicAddressLine1(String)
		- clinicAddressLine2(String)
		- clinicCity(String)
		- clinicDistrict(String)
		- clinicCountry(String)
		- clinicPincode(Integer)
		- clinicOpenTimeMorning(LocalTime)
		- clinicClosingTimeMorning(LocalTime)
		- clinicOpenTimeEvening(LocalTime)
		- clinicClosingTimeEvening(LocalTime)
		- isClinicOpen(Boolean --> columnDefinition = "BOOLEAN DEFAULT TRUE")
		- clinicImages(@Lob List<String> --> multiple images of clinic)

		- clinicDoctors(Set<Doctor> --> OneToMany --> JsonBackReference --> OneClinicHasManyDoctors)

---------------------------------------------------------------------------------------------------------------
Date : 28 March 2024

3)
	3a) create a Appointment entity class with properties and constructors + setter getters + toString()
	3b) create a Prescription entity class with properties and constructors + setter getters + toString()

NOTE :
	Prescribed User must be a person who have taken Appointment.
		From Appointment we can retrieve
			- Appointment details
			- User details who have taken Appointment
			- Doctor details -> Clinic Details			

	Appointment(C)
		- appointmentIdentifier(Integer --> AutoIncrement --> IDENTITY)
		- appointmentBookingDateTime(LocalDateTime --> @CurrentTimeStamp)
		- appointmentScheduledDate(Date)
		- appointmentScheduledTime(LocalTime)
		- isAppointmentSuccessful(Boolean --> columnDefinition = "BOOLEAN DEFAULT FALSE")
		- appointmentUser(User --> @OneToOne --> One Appointment have One User)
		- appointmentDoctor(Doctor --> @ManyToOne --> Many Appointments have One Doctor)

	
	Prescription(C)
		- prescriptionIdentifier(Integer --> AutoIncrement --> IDENTITY)
		- ageOfPatient(Integer)
		- weightOfPatient(Double)
		- heightOfPatient(Integer)
		- prescribedMedicines(List<String> --> multiple medicine may be given)
		- prescriptionAppointment(Appointment --> OneToOne --> One Prescription have One Appointment 
						--> we will get the details of user who booked appointment)

		
---------------------------------------------------------------------------------------------------------------
4) 
	4a) create Repository interfaces for each entity class to perform CRUD operations
		@Repository

		UserRepository(I)
		DoctorRepository(I)	
		ClinicRepository(I)
		AppointmentRepository(I)
		PrescriptionRepository(I)
					----> extends JpaRepository

	4b) create service classes for each entity.
		@Service on Service Classes	
	
		Here, we are using Interface-Class relationship for services.
		UserServiceI(I) - UserServiceImpl(C)
		DoctorServiceI(I) - DoctorServiceImpl(C)
		ClinicServiceI(I) - ClinicServiceImpl(C)
		AppointmentServiceI(I) - AppointmentServiceImpl(C)
		PrescriptionServiceI(I) - PrescriptionServiceImpl(C)

	4c) create controller classes for each entity.
		@RestController

		UserController(C)
		DoctorController(C)
		ClinicController(C)
		AppointmentController(C)
		PrescriptionController(C)

---------------------------------------------------------------------------------------------------------------
Date : 29 March 2024

5)
	5a) Create a BaseResponse(C) which is used to send status code,message and object with ResponseEntity.
			[ ResponseEntity<>(baseReponse,HttpStatus.) ]

		It is a DTO(Data Transfer Object class).
		We will keep it in seperate package.

		BaseResponse<T>(C)
			- statusCode(Integer)
			- message(String)
			- responseData(T --> can be of any type)

	5a) create a rest-api for registering a user.
		- @PostMapping("/registerUser")
		- Take user details in JSON format and store in database.
		- Parameters :
			- @RequestParam("request") String request -- use to capture data coming in request.
				In UserServiceImpl, we use ObjectMapper to map request with User
				ObjectMapper objectMapper = objectMapper.readValue(requset,User.class);

			- Multipart -- for image --> profile picture of user.
				In UserServiceImpl, we save image after converting image into Base64 formated String after converting image into byte[]
				Base64.getEncoder().getEncodeToString(byte[]);

		- In response need to give Status code with registerdUser details.
			To send response we use ResponseEntity.
---------------------------------------------------------------------------------------------------------------
Date : 03 April 2024

6) 
	6a) Update userProfileImage --> columnDefinition = "LONGTEXT" 
		---> It avoids error - data too long for column
	
	
	6b) Generate username automatically to keep unique usernames in format of YYYYMMDD{randomNumber}.
		
		YYYYMMDD
			- LocalDate.getYear() --> year
			- LocalDate.getMonthValue() --> month
			- LocalDate.getDatOfMonth() --> day

		randomNumber
			- random.nextInt(10000) --> nextInt

		Need to convert into String because our username is in String format and values we generated are in int format
			- ""+year+""+month+""+day+""+nextInt
		
	
	REMAINING --- 6c) Need to encrypt password while saving.
		
	
*******	REMAINING --- 6d) Send registered emailid , username and password to newly registered user on his mail id.
 

	6e) Need to check if user is already registered or not on the basic of userEmailId or username.
		findByUserEmailId(user.userEmailId) 
			---> if returns value then email id is existed.
			---> if does not return any value means email id not existed.
			  	
		
		